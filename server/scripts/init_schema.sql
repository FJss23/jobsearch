-- https://www.postgresql.org/docs/9.1/datatype-character.html
-- https://wiki.postgresql.org/wiki/Don't_Do_This
-- https://community.spiceworks.com/topic/2454825-zone-of-misunderstanding

-- Create a custom schema
CREATE SCHEMA IF NOT EXISTS jobsearch;

-- Tables
CREATE TABLE IF NOT EXISTS jobsearch.tag(
	tag_id integer GENERATED BY DEFAULT AS IDENTITY,
    name text NOT NULL CHECK (name <> ''),

    created_at timestamptz DEFAULT CURRENT_TIMESTAMP,
    created_by text,
    updated_at timestamptz,
    updated_by text,

    PRIMARY KEY (tag_id)
);

CREATE TABLE IF NOT EXISTS jobsearch.scraping_source(
    scraping_source_id integer GENERATED BY DEFAULT AS IDENTITY,
    name text CHECK (length(name) < 250),
    base_url text CHECK (length(base_url) < 500),
    url text CHECK (length(url) < 500),
    active boolean NOT NULL,

    created_at timestamptz DEFAULT CURRENT_TIMESTAMP,
    created_by text,
    updated_at timestamptz,
    updated_by text,

    PRIMARY KEY (scraping_source_id)
);

CREATE TYPE job_state AS ENUM ('CREATED', 'EXPIRED', 'CLOSED');

CREATE TABLE IF NOT EXISTS jobsearch.job(
	job_id integer GENERATED BY DEFAULT AS IDENTITY,
	title text NOT NULL CHECK (title <> '' AND length(title) < 600),
	role text CHECK (role <> '' AND length(role) < 250),
	location text CHECK (location <> '' AND length(location) < 250),
	salary_from numeric CHECK (salary_from > 0),
	salary_up_to numeric CHECK (salary_up_to > 0),
	salary_currency text CHECK (salary_currency <> '' AND length(salary_currency) < 10),
	workday text NOT NULL CHECK (workday <> '' AND length(workday) < 50),
	description text NOT NULL CHECK (description <> '' AND length(description) < 5000),
    state job_state NOT NULL,
    work_model text NOT NULL CHECK (work_model <> '' AND length(work_model) < 50),
    company_name text CHECK (length(company_name) < 250),
    company_logo_url text CHECK (length(company_logo_url) < 500),
    ts tsvector GENERATED ALWAYS AS (to_tsvector('english', title) || to_tsvector('english', description)) STORED,
    identifier_from_source text UNIQUE CHECK (length(identifier_from_source) < 250),
    visa_sponsor boolean DEFAULT FALSE,
    scraping_source_id integer,

    created_at timestamptz DEFAULT CURRENT_TIMESTAMP,
    created_by text,
    updated_at timestamptz,
    updated_by text,

    PRIMARY KEY (job_id),
    FOREIGN KEY (scraping_source_id) REFERENCES jobsearch.scraping_source (scraping_source_id) ON DELETE SET NULL (scraping_source_id),
    CHECK (salary_up_to >= salary_from)
);

CREATE TABLE IF NOT EXISTS jobsearch.job_tag(
    job_id integer,
    tag_id integer,

    created_at timestamptz DEFAULT CURRENT_TIMESTAMP,
    created_by text,
    updated_at timestamptz,
    updated_by text,

    PRIMARY KEY (job_id, tag_id),
    FOREIGN KEY (tag_id) REFERENCES jobsearch.tag (tag_id) ON DELETE SET NULL (tag_id),
    FOREIGN KEY (job_id) REFERENCES jobsearch.job (job_id) ON DELETE CASCADE
);

CREATE TYPE appuser_role AS ENUM ('CANDIDATE', 'APP_ADMIN');

CREATE TABLE IF NOT EXISTS jobsearch.appuser(
    appuser_id integer GENERATED BY DEFAULT AS IDENTITY,
    first_name text NOT NULL CHECK (first_name <> '' AND length(first_name) < 150),
    last_name text NOT NULL CHECK (last_name <> '' AND length(last_name) < 150),
    email text UNIQUE NOT NULL CHECK (email <> '' AND length(email) < 150),
    password text NOT NULL CHECK (password <> '' AND length(password) < 100),
    role appuser_role NOT NULL,
    locked boolean DEFAULT FALSE,
    enabled boolean DEFAULT FALSE,
    logged_at timestamptz,

    created_at timestamptz DEFAULT CURRENT_TIMESTAMP,
    created_by text,
    updated_at timestamptz,
    updated_by text,

    PRIMARY KEY (appuser_id)
);

CREATE TABLE IF NOT EXISTS jobsearch.confirmation_token(
    confirmation_token_id integer GENERATED BY DEFAULT AS IDENTITY,
    token text CHECK (length(token) < 300),
    expires_at timestamptz,
    confirmed_at timestamptz,
    appuser_email text NOT NULL CHECK (appuser_email <> '' AND length(appuser_email) < 150),

    created_at timestamptz DEFAULT CURRENT_TIMESTAMP,

    PRIMARY KEY (confirmation_token_id),
    FOREIGN KEY (appuser_email) REFERENCES jobsearch.appuser (email)
);

CREATE TABLE IF NOT EXISTS jobsearch.refresh_token_info(
    refresh_token_info_id integer GENERATED BY DEFAULT AS IDENTITY,
    location text CHECK (length(location) < 250),
    device text CHECK (length(device) < 250),
    appuser_email text NOT NULL CHECK (appuser_email <> '' AND length(appuser_email) < 150),

    created_at timestamptz DEFAULT CURRENT_TIMESTAMP,
    created_by text,
    updated_at timestamptz,
    updated_by text,

    PRIMARY KEY (refresh_token_info_id),
    FOREIGN KEY (appuser_email) REFERENCES jobsearch.appuser (email)
);


CREATE TABLE IF NOT EXISTS jobsearch.email_sent(
    email_sent_id integer GENERATED BY DEFAULT AS IDENTITY,
    source text NOT NULL CHECK (source <> '' AND length(source) < 150),
    destination text NOT NULL CHECK (destination <> '' AND length(destination) < 150),
    event_type text NOT NULL CHECK (event_type <> '' AND length(event_type) < 250),
    message_id text NOT NULL CHECK (length(message_id) < 250),

    created_at timestamptz DEFAULT CURRENT_TIMESTAMP,
    created_by text,
    updated_at timestamptz,
    updated_by text,

    PRIMARY KEY (email_sent_id)
);

CREATE TABLE IF NOT EXISTS jobsearch.keyword_location(
    location_id integer GENERATED BY DEFAULT AS IDENTITY,
    name text CHECK (length(name) < 250),

    created_at timestamptz DEFAULT CURRENT_TIMESTAMP,
    created_by text,
    updated_at timestamptz,
    updated_by text,

    PRIMARY KEY (location_id)
);

CREATE TABLE IF NOT EXISTS jobsearch.scraping_source_deleted(
    scraping_source_id integer GENERATED BY DEFAULT AS IDENTITY,
    name text,
    url text,

    created_at timestamptz DEFAULT CURRENT_TIMESTAMP,
    created_by text,
    updated_at timestamptz,
    updated_by text,

    PRIMARY KEY (scraping_source_id)
);

CREATE TABLE IF NOT EXISTS jobsearch.job_deleted(
	job_id integer GENERATED BY DEFAULT AS IDENTITY,
	title text,
	role text,
	location text,
	salary_from numeric,
	salary_up_to numeric,
	salary_currency text,
	workday text,
	description text,
    state job_state,
    work_model text,
    company_name text,
    company_logo_url text,
    identifier_from_source text,
    visa_sponsor boolean DEFAULT FALSE,
    scraping_source_id integer,

    created_at timestamptz DEFAULT CURRENT_TIMESTAMP,
    created_by text,
    updated_at timestamptz,
    updated_by text,

    PRIMARY KEY (job_id),
    CHECK (salary_up_to >= salary_from)
);

CREATE TABLE IF NOT EXISTS jobsearch.job_tag_deleted(
    job_id integer,
    tag_id integer,

    created_at timestamptz DEFAULT CURRENT_TIMESTAMP,
    created_by text,
    updated_at timestamptz,
    updated_by text,
    deleted_at timestamptz,

    PRIMARY KEY (job_id, tag_id)
);

CREATE TABLE IF NOT EXISTS jobsearch.appuser_deleted(
    appuser_id integer GENERATED BY DEFAULT AS IDENTITY,
    first_name text,
    last_name text,
    email text,
    password text,
    role appuser_role,
    locked boolean DEFAULT FALSE,
    enabled boolean DEFAULT FALSE,
    logged_at timestamptz,

    created_at timestamptz DEFAULT CURRENT_TIMESTAMP,
    created_by text,
    updated_at timestamptz,
    updated_by text,

    PRIMARY KEY (appuser_id)
);

-- Index
CREATE INDEX ts_idx ON jobsearch.job USING GIN (ts);

-- Triggers
CREATE FUNCTION update_value_updated_at() RETURNS TRIGGER AS $$
    BEGIN
       NEW.updated_at = now();
       RETURN NEW;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tag_updated_at_automatic
    BEFORE UPDATE ON jobsearch.tag
    FOR EACH ROW
    EXECUTE FUNCTION update_value_updated_at();

CREATE TRIGGER job_updated_at_automatic
    BEFORE UPDATE ON jobsearch.job
    FOR EACH ROW
    EXECUTE FUNCTION update_value_updated_at();

CREATE TRIGGER job_tag_updated_at_automatic
    BEFORE UPDATE ON jobsearch.job_tag
    FOR EACH ROW
    EXECUTE FUNCTION update_value_updated_at();

CREATE TRIGGER appuser_updated_at_automatic
    BEFORE UPDATE ON jobsearch.appuser
    FOR EACH ROW
    EXECUTE FUNCTION update_value_updated_at();

CREATE TRIGGER confirmation_token_updated_at_automatic
    BEFORE UPDATE ON jobsearch.confirmation_token
    FOR EACH ROW
    EXECUTE FUNCTION update_value_updated_at();

CREATE TRIGGER refresh_token_info_updated_at_automatic
    BEFORE UPDATE ON jobsearch.refresh_token_info
    FOR EACH ROW
    EXECUTE FUNCTION update_value_updated_at();

CREATE TRIGGER email_sent_updated_at_automatic
    BEFORE UPDATE ON jobsearch.email_sent
    FOR EACH ROW
    EXECUTE FUNCTION update_value_updated_at();

CREATE TRIGGER scraping_source_updated_at_automatic
    BEFORE UPDATE ON jobsearch.scraping_source
    FOR EACH ROW
    EXECUTE FUNCTION update_value_updated_at();

CREATE FUNCTION insert_after_delete_job() RETURNS TRIGGER AS $$
    BEGIN
        INSERT
        INTO jobsearch.job_deleted(
            title,
            role,
            location,
            salary_from,
            salary_up_to,
            salary_currency,
            workday,
            description,
            state,
            work_model,
            company_name,
            company_logo_url,
            identifier_from_source,
            visa_sponsor,
            scraping_source_id)
        VALUES(
            NEW.title,
            NEW.role,
            NEW.location,
            NEW.salary_from,
            NEW.salary_up_to,
            NEW.salary_currency,
            NEW.workday,
            NEW.description,
            NEW.state,
            NEW.work_model,
            NEW.company_name,
            NEW.company_logo_url,
            NEW.identifier_from_source,
            NEW.visa_sponsor,
            NEW.scraping_source_id);

        RETURN NEW;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER copy_deleted_job
    AFTER DELETE ON jobsearch.job
    FOR EACH ROW
    EXECUTE FUNCTION insert_after_delete_job();

CREATE FUNCTION insert_after_delete_scraping_source() RETURNS TRIGGER AS $$
    BEGIN
        INSERT
        INTO jobsearch.scraping_source_deleted(
            name,
            url)
        VALUES(
            NEW.name,
            NEW.url);
        RETURN NEW;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER copy_deleted_scraping_source
    AFTER DELETE ON jobsearch.scraping_source
    FOR EACH ROW
    EXECUTE FUNCTION insert_after_delete_scraping_source();

CREATE FUNCTION insert_after_delete_job_tag() RETURNS TRIGGER AS $$
    BEGIN
        INSERT
        INTO jobsearch.job_tag_deleted(
            job_id,
            tag_id)
        VALUES(
            NEW.job_id,
            NEW.tag_id);
        RETURN NEW;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER copy_deleted_job_tag
    AFTER DELETE ON jobsearch.job_tag
    FOR EACH ROW
    EXECUTE FUNCTION insert_after_delete_job_tag();

CREATE FUNCTION insert_after_delete_appuser() RETURNS TRIGGER AS $$
    BEGIN
        INSERT
        INTO jobsearch.appuser_deleted(
            appuser,
            first_name,
            last_name,
            email,
            password,
            role,
            locked,
            enabled,
            logged_at)
        VALUES(
            NEW.appuser,
            NEW.first_name,
            NEW.last_name,
            NEW.email,
            NEW.password,
            NEW.role,
            NEW.locked,
            NEW.enabled,
            NEW.logged_at);
        RETURN NEW;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER copy_deleted_appuser
    AFTER DELETE ON jobsearch.appuser
    FOR EACH ROW
    EXECUTE FUNCTION insert_after_delete_appuser();

INSERT INTO jobsearch.tag(name)
VALUES ('.NET'),
    ('AI'),
    ('ASP.NET Core'),
    ('ASP.NET'),
    ('AWS'),
    ('Android'),
    ('Angular'),
    ('Apache Kafka'),
    ('Apache Spark'),
    ('Assembly'),
    ('Bash'),
    ('Blazor'),
    ('C#'),
    ('C'),
    ('C++'),
    ('CMake'),
    ('CSS'),
    ('Capacitor'),
    ('Cassandra'),
    ('Clojure'),
    ('Cobol'),
    ('Cordoba'),
    ('CouchDB'),
    ('Couchbase'),
    ('Crystal'),
    ('Dart'),
    ('Database'),
    ('Delphi'),
    ('Deno'),
    ('Django'),
    ('Docker'),
    ('Drupal'),
    ('DynamoDB'),
    ('Elasticsearch'),
    ('Electron'),
    ('Elixir'),
    ('Erlang'),
    ('Express'),
    ('F#'),
    ('FastAPI'),
    ('Figma'),
    ('Firebase'),
    ('Flutter'),
    ('Fortran'),
    ('Fullstack'),
    ('GTK'),
    ('Gatbsy'),
    ('Go'),
    ('Golang'),
    ('Godot'),
    ('Google Cloud'),
    ('Gradle'),
    ('Grafana'),
    ('Groovy'),
    ('HTML'),
    ('Hadoop'),
    ('Haskell'),
    ('Heroku'),
    ('Kubernetes'),
    ('K8s'),
    ('Hibernate'),
    ('IBM DB2'),
    ('Ionic'),
    ('Java'),
    ('JavaScript'),
    ('Jenkings'),
    ('Julia'),
    ('LISP'),
    ('Laravel'),
    ('Liferay'),
    ('Lisp'),
    ('Lua'),
    ('MATLAB'),
    ('Machine Learning'),
    ('MariaDB'),
    ('Maven'),
    ('Microsoft Azure'),
    ('Microsoft SQL Server'),
    ('MongoDB'),
    ('MySQL'),
    ('Neo4j'),
    ('NestJS'),
    ('NextJS'),
    ('NodeJS'),
    ('NumPy'),
    ('NuxtJS'),
    ('OCaml'),
    ('Objective-C'),
    ('Oracle'),
    ('PHP'),
    ('Pandas'),
    ('Pandas'),
    ('Perl'),
    ('Phoenix'),
    ('PostgreSQL'),
    ('Postgres'),
    ('Powershell'),
    ('Prometheus'),
    ('PyTorch'),
    ('Python'),
    ('Qt'),
    ('R'),
    ('React Native'),
    ('React Query'),
    ('React'),
    ('Redis'),
    ('Redux'),
    ('RoR'),
    ('Ruby'),
    ('Rust'),
    ('SASS'),
    ('SQL'),
    ('SQLite'),
    ('Scala'),
    ('Selenium'),
    ('Shopify'),
    ('Sinatra'),
    ('Solidity'),
    ('Spring Boot'),
    ('Spring'),
    ('Struts'),
    ('Svelte'),
    ('Swift'),
    ('Symfony'),
    ('TensorFlow'),
    ('Terraform'),
    ('TypeScript'),
    ('Unity 3D'),
    ('Unreal Engine'),
    ('VBA'),
    ('Vue'),
    ('Wordpress'),
    ('Kotlin'),
    ('RabbitMQ'),
    ('Xamarin'),
    ('iOS'),
    ('Debian'),
    ('Nginx'),
    ('IoT'),
    ('jQuery');

INSERT INTO jobsearch.keyword_location(name)
VALUES ('EU'),
    ('Europe'),
    ('Worldwide'),
    ('Austria'),
    ('Vienna'),
    ('Belgium'),
    ('Brussels'),
    ('Bulgaria'),
    ('Sofia'),
    ('Cyprus'),
    ('Czech Republic'),
    ('Prague'),
    ('Denmark'),
    ('Copenhagen'),
    ('Estonia'),
    ('Finland'),
    ('Helsinki'),
    ('France'),
    ('Paris'),
    ('Germany'),
    ('Berlin'),
    ('Greece'),
    ('Athens'),
    ('Hungary'),
    ('Budapest'),
    ('Ireland'),
    ('Dublin'),
    ('Italy'),
    ('Rome'),
    ('Latvia'),
    ('Riga'),
    ('Lithuania'),
    ('Vilnius'),
    ('Luxembourg'),
    ('Malta'),
    ('Valletta'),
    ('Netherlands'),
    ('Amsterdam'),
    ('Poland'),
    ('Warsaw'),
    ('Portugal'),
    ('Lisbon'),
    ('Romania'),
    ('Bucharest'),
    ('Slovakia'),
    ('Bratislava'),
    ('Slovenia'),
    ('Ljubljana'),
    ('Spain'),
    ('Madrid'),
    ('Barcelona'),
    ('Sweden'),
    ('Stockholm'),
    ('Croatia'),
    ('Zagreb'),
    ('UK'),
    ('England'),
    ('London');

-- Software Engineer
-- Backend Engineer
-- Backend  Developer
-- Backend Technical Lead
-- Frontend Engineer
-- Frontend Developer
-- Frontend Technical Lead
-- Fullstack Engineer
-- Fullstack Developer
-- Accessibility Developer
-- Cloud Developer
-- iOS Developer
-- Android Developer
-- UI Designer
-- Site Reliability Engineer
-- Product Manager
-- Data Scientist
-- System Engineer
-- Principal Engineer
-- DevOps Engineer
-- Founding Engineer
